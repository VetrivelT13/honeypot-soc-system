# =============================================================================
# alerts/email_alert.py — SMTP Email Alert Module
# Sends formatted SOC alerts via email. Runs in background threads.
# Failure is always caught and logged — never crashes the main system.
# =============================================================================

import smtplib
import logging
import time
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from datetime import datetime

import sys
sys.path.insert(0, r"C:\Users\vetri\Desktop\FYProject")
import config

logger = logging.getLogger(__name__)

_SEVERITY_COLOUR = {
    "Critical": "#b71c1c",
    "High":     "#e53935",
    "Medium":   "#fb8c00",
    "Low":      "#43a047",
}

_HTML_TEMPLATE = """\
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  body {{ font-family: 'Segoe UI', Arial, sans-serif; background: #f0f2f5; padding: 0; margin: 0; }}
  .wrapper {{ max-width: 620px; margin: 30px auto; }}
  .header {{
    background: {header_color};
    color: #fff;
    padding: 24px 30px;
    border-radius: 10px 10px 0 0;
  }}
  .header h1 {{ font-size: 20px; margin: 0 0 4px; }}
  .header p  {{ font-size: 13px; opacity: 0.85; margin: 0; }}
  .body {{
    background: #fff;
    padding: 28px 30px;
    border: 1px solid #e0e0e0;
    border-top: none;
  }}
  .badge {{
    display: inline-block;
    background: {header_color};
    color: #fff;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 700;
    margin-bottom: 18px;
  }}
  table {{ width: 100%; border-collapse: collapse; margin-top: 10px; }}
  th, td {{ padding: 10px 14px; text-align: left; border-bottom: 1px solid #f0f0f0; font-size: 13px; }}
  th {{ background: #f8f9ff; color: #555; font-weight: 600; width: 35%; }}
  td {{ color: #222; }}
  .payload {{
    background: #263238;
    color: #80cbc4;
    padding: 14px;
    border-radius: 6px;
    font-family: Consolas, monospace;
    font-size: 12px;
    word-break: break-all;
    margin-top: 16px;
  }}
  .footer {{
    background: #f8f9ff;
    padding: 14px 30px;
    border: 1px solid #e0e0e0;
    border-top: none;
    border-radius: 0 0 10px 10px;
    font-size: 11px;
    color: #999;
    text-align: center;
  }}
</style>
</head>
<body>
<div class="wrapper">
  <div class="header">
    <h1>&#128680; SOC ALERT — {severity} Threat Detected</h1>
    <p>Automated alert from the Honeypot SOC Monitoring System</p>
  </div>
  <div class="body">
    <div class="badge">{severity} | Risk Score: {risk_score}/10</div>
    <table>
      <tr><th>Alert ID</th>       <td>ATK-{attack_id}</td></tr>
      <tr><th>Timestamp (UTC)</th><td>{timestamp}</td></tr>
      <tr><th>Attacker IP</th>    <td>{ip_address}</td></tr>
      <tr><th>Country</th>        <td>{country}</td></tr>
      <tr><th>City</th>           <td>{city}</td></tr>
      <tr><th>Service</th>        <td>{service}</td></tr>
      <tr><th>Attack Type</th>    <td>{attack_type}</td></tr>
      <tr><th>Rule Triggered</th> <td>{rule}</td></tr>
      <tr><th>Severity</th>       <td>{severity}</td></tr>
      <tr><th>Risk Score</th>     <td>{risk_score} / 10</td></tr>
    </table>
    <div class="payload"><strong>Payload:</strong><br>{payload}</div>
  </div>
  <div class="footer">
    &#128274; This is an automated alert generated by the Honeypot SOC System.
    Do not reply to this email. &nbsp;|&nbsp; {generated_at} UTC
  </div>
</div>
</body>
</html>
"""


class EmailAlert:
    """
    Sends HTML email alerts via SMTP.
    Each send() call is intended to run in a background daemon thread.
    """

    IP_COOLDOWN_SECS = 60   # 1 email per attacker IP per minute

    def __init__(self):
        self.enabled   = config.EMAIL_ENABLED
        self.sender    = config.EMAIL_SENDER
        self.password  = config.EMAIL_PASSWORD
        self.recipient = config.EMAIL_RECIPIENT
        self.smtp_host = config.EMAIL_SMTP_HOST
        self.smtp_port = config.EMAIL_SMTP_PORT
        self._ip_last_sent = {}   # ip -> last sent timestamp

    def send(self, attack_record: dict):
        """
        Send an email for every NEW attacker IP event.
        If the same IP attacks repeatedly, only 1 email per 60 seconds.
        Different IPs always get their own email immediately.
        """
        if not self.enabled:
            return

        ip  = attack_record.get("ip_address", "unknown")
        now = time.time()

        # Skip if same IP already alerted within cooldown window
        if now - self._ip_last_sent.get(ip, 0) < self.IP_COOLDOWN_SECS:
            return

        self._ip_last_sent[ip] = now

        try:
            subject, html_body = self._build_message(attack_record)
            self._send_smtp(subject, html_body)
            logger.info("Email alert sent for attack %s from %s",
                        attack_record.get("id"), ip)
        except Exception as e:
            logger.error("Email alert failed: %s", e)

    # ── Private helpers ────────────────────────────────────────────────────────

    def _build_message(self, rec: dict) -> tuple:
        severity   = rec.get("severity", "Unknown")
        colour     = _SEVERITY_COLOUR.get(severity, "#616161")
        attack_id  = rec.get("id", "N/A")
        subject    = (f"[SOC ALERT] {severity} | {rec.get('attack_type','Unknown')} | "
                      f"IP: {rec.get('ip_address','?')} | Score: {rec.get('risk_score',0)}/10")

        html_body = _HTML_TEMPLATE.format(
            header_color = colour,
            severity     = severity,
            attack_id    = attack_id,
            timestamp    = rec.get("timestamp", "N/A"),
            ip_address   = rec.get("ip_address", "N/A"),
            country      = rec.get("country", "Unknown"),
            city         = rec.get("city", "Unknown"),
            service      = rec.get("service", "N/A").upper(),
            attack_type  = rec.get("attack_type", "N/A"),
            rule         = rec.get("rule", "N/A"),
            risk_score   = rec.get("risk_score", 0),
            payload      = (rec.get("payload", "") or "")[:800],
            generated_at = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S"),
        )
        return subject, html_body

    def _send_smtp(self, subject: str, html_body: str):
        msg = MIMEMultipart("alternative")
        msg["Subject"] = subject
        msg["From"]    = self.sender
        msg["To"]      = self.recipient
        msg.attach(MIMEText(html_body, "html"))

        with smtplib.SMTP(self.smtp_host, self.smtp_port, timeout=20) as server:
            server.ehlo()
            server.starttls()
            server.ehlo()
            server.login(self.sender, self.password)
            server.sendmail(self.sender, self.recipient, msg.as_string())
